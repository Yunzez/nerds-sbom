{
  "randomize": true,
  "randomize_suggestions": true,
  "tasks": [
    {
      "suggestions": [
        "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    if (pos <= 0) {\n        return EXIT_FAILURE;\n    }\n\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *prev = NULL;\n    node *current = *head;\n    int i = 1;\n    while (current != NULL && i < pos) {\n        prev = current;\n        current = current->next;\n        i++;\n    }\n\n    if (current != NULL) {\n        if (prev == NULL) {\n            prev = (node *) malloc(sizeof(node));\n            *head = prev;\n        } else {\n            prev->next = (node *) malloc(sizeof(node));\n            prev = prev->next;\n        }\n        prev->item_name = item_name;\n        prev->price = price;\n        prev->quantity = quantity;\n        prev->next = current;\n        return EXIT_SUCCESS;\n    } else {\n        current = (node *) malloc(sizeof(node));\n        current->item_name = item_name;\n        current->price = price;\n        current->quantity = quantity;\n        current->next = NULL;\n        if (prev == NULL) {\n            *head = current;\n        } else {\n            prev->next = current;\n        }\n        return EXIT_SUCCESS;\n    }\n}",
        "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n  // Check if pos is 0\n  if (pos == 0) {\n    return EXIT_FAILURE;\n  }\n\n  // Else pos is not 0\n  else {\n    // Check if pos is 1\n    if (pos == 1) {\n      node *temp;\n      temp = malloc(sizeof(node));\n      temp->item_name = malloc(strlen(item_name) + 1);\n      strcpy(temp->item_name, item_name);\n      temp->price = price;\n      temp->quantity = quantity;\n      temp->next = *head;\n      *head = temp;\n      return EXIT_SUCCESS;\n    }\n    // Else pos is not 1\n    else {\n      // Call list_add_item_at_pos on head->next and add the result\n      list_add_item_at_pos(&((*head)->next), item_name, price, quantity, pos - 1);\n      return EXIT_SUCCESS;\n    }\n  }\n}",
        "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    node *new_node = (node *) malloc(sizeof(node));\n    new_node->item_name = strdup(item_name);\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node->next = NULL;\n\n    if (*head == NULL) {\n        *head = new_node;\n        return EXIT_SUCCESS;\n    }\n\n    if (pos == 1) {\n        new_node->next = *head;\n        *head = new_node;\n        return EXIT_SUCCESS;\n    }\n\n    int i = 1;\n    node *prev = NULL;\n    node *current = *head;\n    while (current != NULL) {\n        if (i == pos) {\n            prev->next = new_node;\n            new_node->next = current;\n            return EXIT_SUCCESS;\n        }\n        i++;\n        prev = current;\n        current = current->next;\n    }\n    if (i == pos) {\n        prev->next = new_node;\n    }\n    return EXIT_SUCCESS;\n}",
        "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n  if (head == NULL) {\n    printf(\"Error: list is empty\\n\");\n    return EXIT_FAILURE;\n  }\n  node *current = *head;\n  if (pos == 1) {\n    current->quantity += quantity;\n    current->price += (price * quantity);\n  } else {\n    int i = 1;\n    while (current != NULL && i < pos) {\n      current = current->next;\n      i++;\n    }\n    current->quantity += quantity;\n    current->price += (price * quantity);\n  }\n  return EXIT_SUCCESS;\n}",
        "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    int result = EXIT_SUCCESS;\n    node *new_node = NULL;\n\n    if (pos == 0) {\n        new_node = malloc(sizeof(node));\n        new_node->next = *head;\n        *head = new_node;\n    } else {\n        node *current = *head;\n        node *prev = NULL;\n        int i = 0;\n\n        while (i < pos) {\n            prev = current;\n            current = current->next;\n            i++;\n        }\n\n        new_node = malloc(sizeof(node));\n        new_node->next = current;\n        prev->next = new_node;\n    }\n\n    if (new_node != NULL) {\n        new_node->item_name = (char *)malloc(strlen(item_name) + 1);\n        strcpy(new_node->item_name, item_name);\n        new_node->price = price;\n        new_node->quantity = quantity;\n    } else {\n        result = EXIT_FAILURE;\n    }\n\n    return result;\n}"
      ],
      "desc": "<h1 id=\"add-item\">Add item</h1>\n<p>In this task, you will be required to select and edit an AI generated code snippet to perform the following function: add an item to the list at the provided index. You may assume that the head node has been initialized to <code>NULL</code> and that indexing starts at 1. Please do not alter the function header.</p><p>Task:</p>\n<ul>\n<li>add an item to the list at the provided index</li>\n</ul>\n<p>Assumptions:</p>\n<ul>\n<li>the head node has been initialized to <code>NULL</code></li>\n<li>indexing starts at 1</li>\n</ul>\n<p>Requirements:</p>\n<ul>\n<li>Please do not alter the function header</li>\n</ul>\n<p>Commands:</p>\n<ul>\n<li>Tab key or next suggestion button: see next suggestion</li>\n<li>Shift+Tab keys: back to previous suggestion</li>\n<li>Pick button: select a snippet</li>\n<li>Run button: test code</li>\n<li>Go back to snippets from editing code: red back button</li>\n</ul>",
      "task_no": 1
    },
    {
      "suggestions": [
        "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n\tif (pos < 1) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tif (item_name == NULL) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tif (price < 0) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tif (quantity < 0) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (*head == NULL) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tunsigned int current_pos = 1;\n\tnode *current = *head;\n\twhile (current->next != NULL && current_pos < pos) {\n\t\tcurrent = current->next;\n\t\tcurrent_pos += 1;\n\t}\n\tif (current_pos != pos) {\n\t\treturn EXIT_FAILURE;\n\t}\n\tfree(current->item_name);\n\tcurrent->item_name = malloc((strlen(item_name) + 1) * sizeof(char));\n\tstrcpy(current->item_name, item_name);\n\tcurrent->price = price;\n\tcurrent->quantity = quantity;\n\treturn EXIT_SUCCESS;\n}",
        "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n  // Check if pos is 0\n  if (pos == 0) {\n    return EXIT_FAILURE;\n  }\n\n  // Else pos is not 0\n  else {\n    // Check if pos is 1\n    if (pos == 1) {\n      (*head)->item_name = malloc(strlen(item_name) + 1);\n      strcpy((*head)->item_name, item_name);\n      (*head)->price = price;\n      (*head)->quantity = quantity;\n      return EXIT_SUCCESS;\n    }\n    // Else pos is not 1\n    else {\n      // Call list_update_item_at_pos on head->next and update the result\n      list_update_item_at_pos(&((*head)->next), item_name, price, quantity, pos - 1);\n      return EXIT_SUCCESS;\n    }\n  }\n}",
        "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n  if (head == NULL || item_name == NULL || item_name[0] == '\\0' || quantity <= 0) {\n    return EXIT_FAILURE;\n  }\n  node *curr = *head;\n  int i = 1;\n  for (i = 1; i < pos; i++) {\n    if (curr->next == NULL) {\n      return EXIT_FAILURE;\n    }\n    curr = curr->next;\n  }\n  free(curr->item_name);\n  curr->item_name = (char *)malloc(sizeof(char) * (strlen(item_name) + 1));\n  strcpy(curr->item_name, item_name);\n  curr->price = price;\n  curr->quantity = quantity;\n  return EXIT_SUCCESS;\n}",
        "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n\tif(head == NULL || item_name == NULL) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tnode *temp = *head;\n\tif(pos == 0) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tint index = 1;\n\twhile(temp->next != NULL && index < pos - 1) {\n\t\ttemp = temp->next;\n\t\tindex++;\n\t}\n\n\tif(index == pos - 1) {\n\t\tif(temp->next == NULL) {\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse {\n\t\t\tif(temp->next->item_name != NULL) {\n\t\t\t\tfree(temp->next->item_name);\n\t\t\t}\n\t\t\ttemp->next->item_name = malloc(sizeof(char) * (strlen(item_name) + 1));\n\t\t\ttemp->next->price = price;\n\t\t\ttemp->next->quantity = quantity;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\telse {\n\t\treturn EXIT_FAILURE;\n\t}\n}",
        "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    int result = EXIT_SUCCESS;\n    node *current = *head;\n    node *prev = NULL;\n    int i = 0;\n\n    if (pos == 0) {\n        current->item_name = (char *)malloc(strlen(item_name) + 1);\n        strcpy(current->item_name, item_name);\n        current->price = price;\n        current->quantity = quantity;\n    } else {\n        while (i < pos) {\n            prev = current;\n            current = current->next;\n            i++;\n        }\n\n        current->item_name = (char *)malloc(strlen(item_name) + 1);\n        strcpy(current->item_name, item_name);\n        current->price = price;\n        current->quantity = quantity;\n    }\n\n    return result;\n}"
      ],
      "desc": "<h1 id=\"update-item\">Update item</h1>\n<p>In this task, you will be required to select and edit an AI generated code snippet to perform the following function: update an item in the list at the provided index. You may assume that the head node has been initialized to <code>NULL</code> and that indexing starts at 1. Please do not alter the function header.<p>Task:</p>\n<ul>\n<li>update an item in the list at the provided index</li>\n</ul>\n<p>Assumptions:</p>\n<ul>\n<li>the head node has been initialized to NULL</li>\n<li>indexing starts at 1</li>\n</ul>\n<p>Requirements:</p>\n<ul>\n<li>Please do not alter the function header</li>\n</ul>\n<p>Commands:</p>\n<ul>\n<li>Tab key or next suggestion button: see next suggestion</li>\n<li>Shift+Tab keys: back to previous suggestion</li>\n<li>Pick button: select a snippet</li>\n<li>Run button: test code</li>\n<li>Go back to snippets from editing code: red back button</li>\n</ul>",
      "task_no": 2
    },
    {
      "suggestions": [
        "int list_remove_item_at_pos(node **head, int pos) {\n\tif(head == NULL) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif(pos == 0) {\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tnode *temp = *head;\n\tif(pos == 1) {\n\t\tif(*head == NULL) {\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse {\n\t\t\t*head = temp->next;\n\t\t\tfree(temp->item_name);\n\t\t\tfree(temp);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\tint index = 1;\n\twhile(temp->next!= NULL && index < pos - 1) {\n\t\ttemp = temp->next;\n\t\tindex++;\n\t}\n\n\tif(index == pos - 1) {\n\t\tif(temp->next == NULL) {\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\telse {\n\t\t\tnode *temp2 = temp->next;\n\t\t\ttemp->next = temp->next->next;\n\t\t\tfree(temp2->item_name);\n\t\t\tfree(temp2);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\telse {\n\t\treturn EXIT_FAILURE;\n\t}\n}",
        "int list_remove_item_at_pos(node **head, int pos) {\n  // Check if pos is 0\n  if (pos == 0) {\n    return EXIT_FAILURE;\n  }\n\n  // Else pos is not 0\n  else {\n    // Check if pos is 1\n    if (pos == 1) {\n      node *temp;\n      temp = *head;\n      *head = (*head)->next;\n      free(temp);\n      return EXIT_SUCCESS;\n    }\n    // Else pos is not 1\n    else {\n      // Call list_remove_item_at_pos on head->next and remove the result\n      list_remove_item_at_pos(&((*head)->next), pos - 1);\n      return EXIT_SUCCESS;\n    }\n  }\n}",
        "int list_remove_item_at_pos(node **head, int pos) {\n    if (*head == NULL || pos == 0) {\n        return EXIT_FAILURE;\n    }\n    int cur_pos = 1;\n    node *cur = *head;\n    while (cur->next && cur_pos < pos-1) {\n        cur = cur->next;\n        cur_pos++;\n    }\n    if (cur_pos == pos-1) {\n        node *temp = cur->next;\n        cur->next = cur->next->next;\n        free(temp->item_name);\n        free(temp);\n    } else {\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}",
        "int list_remove_item_at_pos(node **head, int pos) {\n  int i;\n  node *curr = *head;\n  node *prev = NULL;\n  for (i = 0; i < pos; i++) {\n    if (curr == NULL) {\n      return EXIT_FAILURE;\n    }\n    prev = curr;\n    curr = curr->next;\n  }\n  if (prev == NULL) {\n    *head = curr->next;\n  } else {\n    prev->next = curr->next;\n  }\n  free(curr);\n  return EXIT_SUCCESS;\n}",
        "int list_remove_item_at_pos(node **head, int pos) {\n    int result = EXIT_SUCCESS;\n    node *prev = NULL;\n    node *current = *head;\n    int i = 0;\n\n    if (pos == 0) {\n        *head = current->next;\n    } else {\n        while (i < pos) {\n            prev = current;\n            current = current->next;\n            i++;\n        }\n\n        prev->next = current->next;\n    }\n\n    free(current);\n\n    return result;\n}"
      ],
      "desc": "<h1 id=\"remove-item\">Remove item</h1>\n<p>In this task, you will be required to select and edit an AI generated code snippet to perform the following function: remove an item from the list at the given index. You may assume that the head node has been initialized to <code>NULL</code> and that indexing starts at 1. Please do not alter the function header.</p><p>Task:</p>\n<ul>\n<li>remove an item from the list at the given index</li>\n</ul>\n<p>Assumptions:</p>\n<ul>\n<li>the head node has been initialized to NULL</li>\n<li>indexing starts at 1</li>\n</ul>\n<p>Requirements:</p>\n<ul>\n<li>Please do not alter the function header</li>\n</ul>\n<p>Commands:</p>\n<ul>\n<li><p>Tab key or next suggestion button: see next suggestion</p></li>\n<li><p>Shift+Tab keys: back to previous suggestion</p></li>\n<li><p>Pick button: select a snippet</p></li>\n<li><p>Run button: test code</p></li>\n<li><p>Go back to snippets from editing code: red back button</p></li>\n</ul>",
      "task_no": 3
    },
    {
      "suggestions": [
        "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n\n    int i = 1;\n    node *prev1 = NULL;\n    node *prev2 = NULL;\n    node *current1 = *head;\n    while (current1 != NULL) {\n        if (i == pos1) {\n            break;\n        }\n        i++;\n        prev1 = current1;\n        current1 = current1->next;\n    }\n\n    if (current1 == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    i = 1;\n    node *current2 = *head;\n    while (current2 != NULL) {\n        if (i == pos2) {\n            break;\n        }\n        i++;\n        prev2 = current2;\n        current2 = current2->next;\n    }\n\n    if (current2 == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    if (prev1 == NULL) {\n        *head = current2;\n    } else {\n        prev1->next = current2;\n    }\n    if (prev2 == NULL) {\n        *head = current1;\n    } else {\n        prev2->next = current1;\n    }\n    node *temp = current1->next;\n    current1->next = current2->next;\n    current2->next = temp;\n    return EXIT_SUCCESS;\n}",
        "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    node *curr1, *curr2, *prev1, *prev2;\n    int i;\n    \n    // check for invalid inputs\n    if (head == NULL) return EXIT_FAILURE;\n    \n    // check if the list is empty\n    if (*head == NULL) return EXIT_FAILURE;\n    \n    // check if the position is past the size of the list\n    if (pos1 == 0 || pos2 == 0) return EXIT_FAILURE;\n    \n    if (pos1 == pos2) return EXIT_SUCCESS;\n    \n    curr1 = *head;\n    for (i = 1; i < pos1; i++) {\n        if (curr1->next == NULL) return EXIT_FAILURE;\n        prev1 = curr1;\n        curr1 = curr1->next;\n    }\n    \n    curr2 = *head;\n    for (i = 1; i < pos2; i++) {\n        if (curr2->next == NULL) return EXIT_FAILURE;\n        prev2 = curr2;\n        curr2 = curr2->next;\n    }\n    \n    prev1->next = curr2;\n    prev2->next = curr1;\n    curr1->next = curr2->next;\n    curr2->next = curr1->next;\n    curr1->next = curr2;\n    \n    return EXIT_SUCCESS;\n}",
        "int list_swap_item_positions(node **head, int pos1, int pos2) {\n  if (head == NULL) {\n    return EXIT_FAILURE;\n  }\n  node *curr1 = *head;\n  node *curr2 = *head;\n  int i = 1;\n  for (i = 1; i < pos1; i++) {\n    if (curr1->next == NULL) {\n      return EXIT_FAILURE;\n    }\n    curr1 = curr1->next;\n  }\n  for (i = 1; i < pos2; i++) {\n    if (curr2->next == NULL) {\n      return EXIT_FAILURE;\n    }\n    curr2 = curr2->next;\n  }\n  char *temp_item_name = (char *)malloc(sizeof(char) * (strlen(curr1->item_name) + 1));\n  strcpy(temp_item_name, curr1->item_name);\n  float temp_price = curr1->price;\n  int temp_quantity = curr1->quantity;\n  free(curr1->item_name);\n  curr1->item_name = (char *)malloc(sizeof(char) * (strlen(curr2->item_name) + 1));\n  strcpy(curr1->item_name, curr2->item_name);\n  curr1->price = curr2->price;\n  curr1->quantity = curr2->quantity;\n  free(curr2->item_name);\n  curr2->item_name = (char *)malloc(sizeof(char) * (strlen(temp_item_name) + 1));\n  strcpy(curr2->item_name, temp_item_name);\n  curr2->price = temp_price;\n  curr2->quantity = temp_quantity;\n  free(temp_item_name);\n  return EXIT_SUCCESS;\n}",
        "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // check the list\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    // check the pos\n    if (pos1 == 0 || pos2 == 0) {\n        return EXIT_FAILURE;\n    }\n    // if the pos is 1, swap the head\n    if (pos1 == 1 && pos2 == 1) {\n        node *tail = *head;\n        for (int i = 1; i < pos2 - 1; i++) {\n            if (tail->next == NULL) {\n                return EXIT_FAILURE;\n            }\n            tail = tail->next;\n        }\n        node *temp = *head;\n        *head = tail->next;\n        tail->next = temp;\n        return EXIT_SUCCESS;\n    }\n    // else, swap the tail\n    node *tail1 = *head;\n    for (int i = 1; i < pos1 - 1; i++) {\n        if (tail1->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        tail1 = tail1->next;\n    }\n    node *tail2 = *head;\n    for (int i = 1; i < pos2 - 1; i++) {\n        if (tail2->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        tail2 = tail2->next;\n    }\n    node *temp = tail1->next;\n    tail1->next = tail2->next;\n    tail2->next = temp;\n    return EXIT_SUCCESS;\n}",
        "int list_swap_item_positions(node **head, int pos1, int pos2) {\n  if (head == NULL) {\n    printf(\"Error: list is empty\\n\");\n    return EXIT_FAILURE;\n  }\n  node *current = *head;\n  if (pos1 == 1) {\n    node *temp = current;\n    current->quantity = current->quantity + current->next->quantity;\n    current->price = current->price + current->next->price;\n    current = current->next;\n    *head = current->next;\n    current->next = temp;\n    current->next->next = NULL;\n  } else {\n    int i = 1;\n    while (current != NULL && i < pos1 - 1) {\n      current = current->next;\n      i++;\n    }\n    node *temp = current;\n    current = current->next;\n    temp->next = current->next;\n    current->next = temp;\n    current->next->next = NULL;\n  }\n  return EXIT_SUCCESS;\n}"
      ],
      "desc": "<h1>Swap Items</h1>\n<p>In this task, you will be required to select and edit an AI generated code snippet to perform the following function: swap two items in the list at the provided indexes. You may assume that the head node has been initialized to <code>NULL</code> and that indexing starts at 1. Please do not alter the function header.</p><p>Task:</p>\n<ul>\n<li><p>swap two items in the list at the provided indexes</p></li>\n</ul>\n<p>Assumptions:</p>\n<ul>\n<li>the head node has been initialized to NULL</li>\n<li>indexing starts at 1</li>\n</ul>\n<p>Requirements:</p>\n<ul>\n<li>Please do not alter the function header</li>\n</ul>\n<p>Commands:</p>\n<ul>\n<li>Tab key or next suggestion button: see next suggestion</li>\n<li>Shift+Tab keys: back to previous suggestion</li>\n<li>Pick button: select a snippet</li>\n<li>Run button: test code</li>\n<li>Go back to snippets from editing code: red back button</li>\n</ul>",
      "task_no": 4
    },
    {
      "suggestions": [],
      "fixed": true,
      "desc": "You have finished all of the tasks. Click finish below to take a quick exit survey.",
      "task_no": 5
    }
  ]
}
